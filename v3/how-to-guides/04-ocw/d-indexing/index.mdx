---
title: Off-chain Indexing
slug: /how-to-guides/v3/ocw/indexing
keywords:
  - off-chain worker
  - ocw
  - indexing
version: '3.0'
section: how to guides
category: ocw
---

<Objectives data={[
  {
    title: 'Goal',
    description: `Having on-chain extrinsics able to write data to node local storage.`
  },
  {
    title: 'Use Cases',
    description: `Passing data from on-chain extrinsics to off-chain workers without writing to on-chain storage.`
  },
]}/>

## Overview

Occasionally on-chain extrinsics need to pass data to off-chain workers with predictable write behavior.
This data could surely be written to on-chain storage and then have off-chain workers reading from the storage, but this involves updating the blockchain state, which may incur cost depends on the runtime configuration and make the data propagate among the blockchain network.
Another way of handing data from on-chain to off-chain context is by saving it in the node local storage via **off-chain indexing**.

As off-chain indexing is called from on-chain extrinsics, if the extrinsic is agreed upon by the blockchain consensus mechanism, then the data written locally is expected to be consistent across all nodes in the network.

Another use cases is that a large chunk of data need to be stored on-chain, verified among the network, and then passed to off-chain workers for further processing.
But plainly saving the data to the storage is expensive, so only the hash of the data is stored on-chain and the full data set is stored in local storage via off-chain indexing.
This data can then be read by off-chain workers later on.

Notice that the same extrinsic could be run multiple times when there are forked blocks, the consequence is that in case non-unique keys are used the data might be overwritten by different forked blocks and the content in the local stroage will be different between nodes.
So developers should be careful in forming the right indexing key to prevent potential overwrites.

## Steps

> Notes
>
> In order to see the off-chain indexing feature in effect, please run Substrate node with off-chain indexing flag *ON*, as `./target/release/substrate --enable-offchain-indexing true ...`

1. Start by building a unique key used for indexing, similar to the following:

  ```rust
  const ONCHAIN_TX_KEY: &[u8] = b"my_pallet::indexing1";

  #[pallet::call]
  impl<T: Config> Pallet<T> {
    #[pallet::weight(100)]
    pub fn extrinsic(origin: OriginFor<T>, number: u64) -> DispatchResult {
      let who = ensure_signed(origin)?;

      let key = Self::derived_key(frame_system::Module::<T>::block_number());
      // ...

      Ok(())
    }
  }

  impl<T: Config> Pallet<T> {
    fn derived_key(block_number: T::BlockNumber) -> Vec<u8> {
      block_number.using_encoded(|encoded_bn| {
        ONCHAIN_TX_KEY.clone().into_iter()
          .chain(b"/".into_iter())
          .chain(encoded_bn)
          .copied()
          .collect::<Vec<u8>>()
      })
    }
  }
  ```

  In the above code within a regular extrinsic, `Self::derived_key()` helper method is called to generate the key used later for indexing.
  Its logic is concatenating a predefined prefix with the current encoded block number and returning it as a vector of bytes.

2. Define the indexing data and save it using off-chain indexing, similar to the following:

  ```rust
  use sp_io::offchain_index;
  const ONCHAIN_TX_KEY: &[u8] = b"my_pallet::indexing1";

  #[derive(Debug, Deserialize, Encode, Decode, Default)]
  struct IndexingData(Vec<u8>, u64);

  #[pallet::call]
  impl<T: Config> Pallet<T> {
    #[pallet::weight(100)]
    pub fn extrinsic(origin: OriginFor<T>, number: u64) -> DispatchResult {
      let who = ensure_signed(origin)?;

      let key = Self::derived_key(frame_system::Module::<T>::block_number());
      let data = IndexingData(b"submit_number_unsigned".to_vec(), number);
      offchain_index::set(&key, &data.encode());
      Ok(())
    }
  }

  impl<T: Config> Pallet<T> {
    // -- skipped for brevity --
  }
  ```

  The indexing data can be any data type that is bound by `Encode`, `Decode`, and `Deserialize` traits.
  In the above code, data is stored via off-chain indexing [`offchain_index::set()`](https://paritytech.github.io/substrate/latest/sp_io/offchain_index/fn.set.html) method.

  Looking over the documentation of [`offchain_index`](https://paritytech.github.io/substrate/latest/sp_io/offchain_index/index.html), you will only see `set()` and `clear()` methods, but not `get()`.
  This means on-chain extrinsics could only write to local storages but not read from them.
  This is because data in local storage hasn't been verified across the network, so having on-chain logic reading and relying on it may break the network consensus.

3. To read the data in off-chain workers, within the `offchain_worker` hook method:

  ```rust
  use sp_runtime::offchain::StorageValueRef;

  #[derive(Debug, Deserialize, Encode, Decode, Default)]
  struct IndexingData(Vec<u8>, u64);

  fn offchain_worker(block_number: T::BlockNumber) {
    // Reading back the off-chain indexing value. It is exactly the same as reading from
    // ocw local storage.
    let key = Self::derived_key(block_number);
    let storage_ref = StorageValueRef::persistent(&key);

    if let Some(Some(data)) = storage_ref.get::<IndexingData>() {
      debug::info!("local storage data: {:?}, {:?}",
        str::from_utf8(&data.0).unwrap_or("error"), data.1);
    } else {
      debug::info!("Error reading from local storage.");
    }

    // -- snip --
  }
  ```

  In this way off-chain workers could read from the node local storage, as explained in [this how-to guide](/how-to-guides/v3/ocw/local-storage/).

## Related material

- [Off-Chain Features](/v3/concepts/off-chain-features/)
- [Local Storage in Off-chain Workers](/how-to-guides/v3/ocw/local-storage/)
